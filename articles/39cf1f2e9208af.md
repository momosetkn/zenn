---
title: Ktor2.3.6 + Firebase Authenticationã‚’secretKeyã®JSONã‚’DIã§å—ã‘å–ã‚‹ã‚ˆã†ã«ä½œã‚‹
emoji: "ğŸ”¥"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["ktor", "kotlin", "firebase", "koin"]
published: true
---

# å‰æ

Koinã‚’ä½¿ã£ãŸDIã§ã€secretKeyã®JSONã®ã‚’å—ã‘å–ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚

- ktor = 2.3.6
- firebase-admin = 9.2.0
- koin = 3.5.0

ã¡ãªã¿ã«ã€[ktor-koin3.5.3ã¾ãŸã¯3.5.2-RC1ã ã¨ã€auto-reloadå¾Œã«å¿œç­”ã—ãªããªã‚‹](https://github.com/InsertKoinIO/koin/issues/1792)ã‚ˆã†ã§ã™ã€‚

ä»¥ä¸‹è¨˜äº‹ã‚’å‚è€ƒã«ã—ã¾ã—ãŸã€‚

[How to use Firebase Authentication with Ktor 2\.0 \- Plus Mobile Apps](https://plusmobileapps.com/2022/08/02/ktor-firebase-auth.html)


# Install

build.gradle.ktsã®dependenciesã«ä»¥ä¸‹è¿½åŠ ã™ã‚‹

```kotlin
// ktor
implementation("io.ktor:ktor-server-auth:2.3.6")
implementation("io.ktor:ktor-server-auth-jwt:2.3.6")

// firebase
implementation("com.google.firebase:firebase-admin:9.2.0")

// koin
implementation("io.insert-koin:koin-core:3.5.0")
implementation("io.insert-koin:koin-ktor:3.5.0")
implementation("io.insert-koin:koin-logger-slf4j:3.5.0")
testImplementation("io.insert-koin:koin-test:3.5.0") {
    // https://github.com/InsertKoinIO/koin/issues/1526
    exclude("org.jetbrains.kotlin", "kotlin-test-junit")
}
```

# Setting Firebase

â€»slf4jã§ãƒ­ã‚°å‡ºåŠ›ã®ã‚³ãƒ¼ãƒ‰ãŒå…¥ã£ã¦ã„ã¾ã™ãŒã€é©å®œã€ãƒ­ã‚°ã®å‡ºåŠ›ã‚’å¤‰æ›´ã—ã¦ãã ã•ã„ã€‚

Ktorã®Authenticationãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®installæ™‚ã«æ¸¡ã™ãŸã‚ã®ã€è¨­å®šã‚’æ›¸ã„ã¦ã„ãã¾ã™ã€‚

```kotlin
// FirebaseConfig.kt
import com.google.auth.oauth2.GoogleCredentials
import com.google.firebase.FirebaseApp
import com.google.firebase.FirebaseOptions
import com.google.firebase.auth.FirebaseToken
import io.ktor.http.auth.HttpAuthHeader
import io.ktor.server.application.ApplicationCall
import io.ktor.server.auth.AuthenticationConfig
import io.ktor.server.auth.AuthenticationFunction
import io.ktor.server.auth.AuthenticationProvider
import io.ktor.server.auth.Principal
import io.ktor.server.auth.parseAuthorizationHeader

data class FirebaseUser(val userId: String, val displayName: String) : Principal

fun AuthenticationConfig.firebase(
    name: String,
    secretKeyJson: String,
    configure: FirebaseConfig.() -> Unit
) {
    FirebaseAdmin.init(secretKeyJson)
    val provider = FirebaseAuthProvider(FirebaseConfig(name).apply(configure))
    register(provider)
}

class FirebaseConfig(name: String) : AuthenticationProvider.Config(name) {
    private val log = org.slf4j.LoggerFactory.getLogger(this::class.java)
    internal var authHeader: (ApplicationCall) -> HttpAuthHeader? = { call ->
        try {
            call.request.parseAuthorizationHeader()
        } catch (ex: IllegalArgumentException) {
            log.warn("failed to parse authorization header", ex)
            null
        }
    }

    var firebaseAuthenticationFunction: AuthenticationFunction<FirebaseToken> = {
        throw NotImplementedError(
            "Firebase  auth validate function is not specified, use firebase { validate { ... } } to fix this"
        )
    }

    fun validate(validate: suspend ApplicationCall.(FirebaseToken) -> FirebaseUser) {
        firebaseAuthenticationFunction = validate
    }
}

object FirebaseAdmin {
    fun init(secretKeyJson: String): FirebaseApp {
        val option = FirebaseOptions.builder()
            .setCredentials(GoogleCredentials.fromStream(secretKeyJson.byteInputStream()))
            .build()
        // Development modeã«ã‚ˆã‚‹Auto-reloadã®éš›ã«ã€å‰å›èµ·å‹•æ™‚ã®FirebaseAppãŒæ®‹ã£ã¦ã„ã‚‹ã¨æ­£å¸¸å‹•ä½œã—ãªã„ãŸã‚ã€æ¶ˆã™
        FirebaseApp.getApps().forEach {
            it.delete()
        }
        return FirebaseApp.initializeApp(option)
    }
}

```

AuthenticationConfig.firebaseã‹ã‚‰å‘¼ã°ã‚Œã‚‹ã€Firebaseã®èªè¨¼ã®ãƒ¡ã‚¤ãƒ³ã¨ãªã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã«ã¤ã„ã¦æ›¸ã„ã¦ã„ãã¾ã™ã€‚

```kotlin
// FirebaseAuthProvider.kt
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.FirebaseToken
import io.ktor.http.HttpStatusCode
import io.ktor.http.auth.HttpAuthHeader
import io.ktor.server.application.ApplicationCall
import io.ktor.server.auth.AuthenticationContext
import io.ktor.server.auth.AuthenticationFailedCause
import io.ktor.server.auth.AuthenticationProvider
import io.ktor.server.auth.Principal
import io.ktor.server.auth.UnauthorizedResponse
import io.ktor.server.response.respond
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.slf4j.Logger

const val FIREBASE_AUTH = "FIREBASE_AUTH"

class FirebaseAuthProvider(config: FirebaseConfig) : AuthenticationProvider(config) {
    private val log = org.slf4j.LoggerFactory.getLogger(this::class.java)
    val authHeader: (ApplicationCall) -> HttpAuthHeader? = config.authHeader
    private val authFunction = config.firebaseAuthenticationFunction

    @Suppress("TooGenericExceptionCaught")
    override suspend fun onAuthenticate(context: AuthenticationContext) {
        val token = authHeader(context.call)

        if (token == null) {
            log.warn("authHeader is null")
            context.call.respond(UnauthorizedResponse(HttpAuthHeader.bearerAuthChallenge(realm = FIREBASE_AUTH)))
            return
        }

        try {
            val principal = verifyFirebaseIdToken(context.call, token, authFunction, log)

            if (principal != null) {
                context.principal(principal)
            } else {
                context.call.respond(HttpStatusCode.Unauthorized)
            }
        } catch (cause: Throwable) {
            val message = cause.message ?: cause.javaClass.simpleName
            log.warn(message, cause)
            context.error(FIREBASE_JWTAUTH_KEY, AuthenticationFailedCause.Error(message))
        }
    }
}

private suspend fun verifyFirebaseIdToken(
    call: ApplicationCall,
    authHeader: HttpAuthHeader,
    tokenData: suspend ApplicationCall.(FirebaseToken) -> Principal?,
    log: Logger
): Principal? {
    val token: FirebaseToken? = try {
        if (authHeader.authScheme == "Bearer" && authHeader is HttpAuthHeader.Single) {
            withContext(Dispatchers.IO) {
                FirebaseAuth.getInstance().verifyIdToken(authHeader.blob)
            }
        } else {
            log.warn("invalid auth header: $authHeader")
            null
        }
    } catch (ex: Exception) {
        log.warn("cannot verify firebase token", ex)
        null
    }
    return token?.let { tokenData(call, token) }
}

private fun HttpAuthHeader.Companion.bearerAuthChallenge(realm: String): HttpAuthHeader =
    HttpAuthHeader.Parameterized("Bearer", mapOf(HttpAuthHeader.Parameters.Realm to realm))

private const val FIREBASE_JWTAUTH_KEY: String = "FirebaseAuth"

```

## å·¥å¤«ã—ãŸã¨ã“ã‚

å…ƒã®è¨˜äº‹ã®ä»¥ä¸‹ã®ã‚ˆã†ã«ã€embeddedServerã®blockã«æ¸¡ã—ã¦ã€è¨­å®šã‚’ã™ã‚‹å ´åˆã€ktor-koinã«ã‚ˆã‚‹injectãŒä½¿ãˆãªã‹ã£ãŸãŸã‚ã€ä»¥ä¸‹ã®ã‚ˆã†ãªembeddedServerã®blockã§å‡¦ç†ã—ãªã„ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚

```kotlin
fun main() {
    embeddedServer(Netty, port = 8080, host = "0.0.0.0") {
        FirebaseAdmin.init()
        configureFirebaseAuth()
    }.start(wait = true)
}
```

`FirebaseApp.initializeApp`ãŒæœ€åˆã«å®Ÿè¡Œã•ã‚Œã‚‹å¿…è¦ãŒã‚ã‚‹ä¸”ã¤deleteã›ãšã«è¤‡æ•°å›å®Ÿè¡Œã•ã‚Œã‚‹ã¨ã¾ãšã„ã‚ˆã†ã§ã€ktorã®auto-reloadã§deleteã›ãšã«è¤‡æ•°å›å®Ÿè¡Œã•ã‚Œã‚‹ã¨ã€ktorã®ã‚µãƒ¼ãƒãƒ¼ãŒå¿œç­”ã—ãªããªã‚‹ã‚ˆã†ã§ã—ãŸã€‚
ãªã®ã§ã€auto-reloadãŒç™ºç”Ÿã—ãŸå ´åˆã«ã€å‰å›åˆæœŸåŒ–ã—ãŸã‚‚ã®ã‚’æ¶ˆã™ãŸã‚ã«FirebaseAppã‚’deleteã—ãŸå¾Œã«ã€`FirebaseApp.initializeApp`ã§åˆæœŸåŒ–ã™ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚

# ä½¿ã„æ–¹

Ktorã®moduleã§ä»¥ä¸‹ã‚’å‘¼ã³å‡ºã™ã€‚

```kotlin
fun Application.configureAuth() {
    val config by inject<AuthConfig>() // ktor--koinã«ã‚ˆã‚‹inject

    install(Authentication) {
        firebase(name = FIREBASE_AUTH, secretKeyJson = config.firebase.secretKeyJson) {
            validate {
                FirebaseUser(it.uid, it.name.orEmpty())
            }
        }
    }
}

```

Firebaseã®èªè¨¼æƒ…å ±ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€firebaseUseré–¢æ•°ã‚’ä½œã£ã¦å‘¼ã³å‡ºã™ã€‚

```kotlin
import io.ktor.server.application.ApplicationCall
import io.ktor.server.application.call
import io.ktor.server.auth.principal
import io.ktor.server.response.respondText
import io.ktor.server.routing.Route
import io.ktor.server.routing.get
import io.ktor.util.pipeline.PipelineContext

fun Route.route() {
    get("/hello") {
        val user = firebaseUser()
        call.respondText("Hello World!$user")
    }
}

fun PipelineContext<Unit, ApplicationCall>.firebaseUser(): FirebaseUser = checkNotNull(call.principal())

```

